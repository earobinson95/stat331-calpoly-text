[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Stat 331/531 Statistical Computing with R",
    "section": "",
    "text": "This book has been modified from material by Susan VanderPlas. See UNL Stat 151: Introduction to Statistical Computing and UNL Stat 850: Computing Tools for Statisticians for her course books with integration of content and videos from Dr. Allison Theobold and Dr. Kelly Bodwin.\nThis text is designed to demonstrate introductory statistical programming concepts and techniques. It is intended as a substitute for hours and hours of video lectures - watching someone code and talk about code is not usually the best way to learn how to code. It’s far better to learn how to code by … coding.\nI hope that you will work through this book week by week over the semester. I have included comics, snark, gifs, YouTube videos, extra resources, and more: my goal is to make this a collection of the best information I can find on statistical programming.\nIn most cases, this book includes way more information than you need. Everyone comes into this class with a different level of computing experience, so I’ve attempted to make this book comprehensive. Unfortunately, that means some people will be bored and some will be overwhelmed. Use this book in the way that works best for you - skip over the stuff you know already, ignore the stuff that seems too complex until you understand the basics. Come back to the scary stuff later and see if it makes more sense to you.\n\n\nI’ve made an effort to use some specific formatting and enable certain features that make this book a useful tool for this class.\n\n\n\n\nWatch out sections contain things you may want to look out for - common errors, etc.\n\n\n\nExample sections contain code and other information. Don’t skip them!\n\n\n\nThese sections contain things you should definitely not consider as fact and should just take with a grain of salt.\n\n\n\nSometimes, there are better resources out there than something I could write myself. When you see this section, go read the enclosed link as if it were part of the book.\n\n\n\nTry it out sections contain activities you should do to reinforce the things you’ve just read.\n\n\n\nCheck-in sections contain activities you must complete and submit to Canvas for credit.\n\n\n\nLearn More sections contain other references that may be useful on a specific topic. Suggestions are welcome (email me to suggest a new reference that I should add), as there’s no way for one person to catalog all of the helpful programming resources on the internet!\n\n\n\nNote sections contain clarification points (anywhere I would normally say “note that ….)\n\n\n\n\n\nThese are expandable sections, with additional information when you click on the line\n\nThis additional information may be information that is helpful but not essential, or it may be that an example just takes a LOT of space and I want to make sure you can skim the book without having to scroll through a ton of output.\n\n\n\nMany times, examples will be in expandable sections\n\nThis keeps the code and output from obscuring the actual information in the textbook that I want you to retain. You can always look up the syntax, but you do need to absorb the details I’ve written out.\n\n\n\n\n\n\nReferences or additional readings may come from the following texts:\n\nR for Data Science (2e)\nAdvanced R\nModern Dive\nStat 545 (Data wrangling, exploration, and analysis with R) by Jenny Bryan\n\nYou can find additional help for Coding in R form the following resources:\n\nRStudio Education Page\nPosit Primers\n“R Bootcamp” Practice"
  },
  {
    "objectID": "00-prereading.html",
    "href": "00-prereading.html",
    "title": "Pre-reading",
    "section": "",
    "text": "Reading: 10 minute(s) at 200 WPM.\nVideos:"
  },
  {
    "objectID": "00-prereading.html#computer-basics",
    "href": "00-prereading.html#computer-basics",
    "title": "Pre-reading",
    "section": "Computer Basics",
    "text": "Computer Basics\nIt is helpful when teaching a topic as technical as programming to ensure that everyone starts from the same basic foundational understanding and mental model of how things work. When teaching geology, for instance, the instructor should probably make sure that everyone understands that the earth is a round ball and not a flat plate – it will save everyone some time later.\nWe all use computers daily - we carry them around with us on our wrists, in our pockets, and in our backpacks. This is no guarantee, however, that we understand how they work or what makes them go.\nHardware\nHere is a short 3-minute video on the basic hardware that makes up your computer. It is focused on desktops, but the same components (with the exception of the optical drive) are commonly found in cell phones, smart watches, and laptops.\n\n\n\n\n\n\nWhen programming, it is usually helpful to understand the distinction between RAM and disk storage (hard drives). We also need to know at least a little bit about processors (so that we know when we’ve asked our processor to do too much). Most of the other details aren’t necessary (for now).\n\n\n\nOperating Systems\nOperating systems, such as Windows, MacOS, or Linux, are a sophisticated program that allows CPUs to keep track of multiple programs and tasks and execute them at the same time.\n\n\n\n\n\n\nFile Systems\nEvidently, there has been a bit of generational shift as computers have evolved: the “file system” metaphor itself is outdated because no one uses physical files anymore. This article is an interesting discussion of the problem: it makes the argument that with modern search capabilities, most people use their computers as a laundry hamper instead of as a nice, organized filing cabinet.\nRegardless of how you tend to organize your personal files, it is probably helpful to understand the basics of what is meant by a computer file system – a way to organize data stored on a hard drive. Since data is always stored as 0’s and 1’s, it’s important to have some way to figure out what type of data is stored in a specific location, and how to interpret it.\n\n\n\n\n\n\nThat’s not enough, though - we also need to know how computers remember the location of what is stored where. Specifically, we need to understand file paths.\n\n\n\n\n\n\nWhen you write a program, you may have to reference external files - data stored in a .csv file, for instance, or a picture. Best practice is to create a file structure that contains everything you need to run your entire project in a single file folder (you can, and sometimes should, have sub-folders).\nFor now, it is enough to know how to find files using file paths, and how to refer to a file using a relative file path from your base folder. In this situation, your “base folder” is known as your working directory - the place your program thinks of as home.\n::: check-in"
  },
  {
    "objectID": "00-prereading.html#vectors-matrices-and-arrays",
    "href": "00-prereading.html#vectors-matrices-and-arrays",
    "title": "Pre-reading",
    "section": "Vectors, Matrices, and Arrays",
    "text": "Vectors, Matrices, and Arrays\n\n\nThis chapter introduces some of the most important tools for working with data: vectors, matrices, loops, and if statements. It would be nice to gradually introduce each one of these topics separately, but they tend to go together, especially when you’re talking about programming in the context of data processing.\nMathematical Logic\nBefore we start talking about data structures and control structures, though, we’re going to take a minute to review some concepts from mathematical logic. This will be useful for both data structures and control structures, so stick with me for a few minutes.\nAnd, Or, and Not\nWe can combine logical statements using and, or, and not.\n\n(X AND Y) requires that both X and Y are true.\n(X OR Y) requires that one of X or Y is true.\n(NOT X) is true if X is false, and false if X is true. Sometimes called negation.\n\nIn R, we use ! to symbolize NOT, in Python, we use ~ for vector-wise negation (NOT).\nOrder of operations dictates that NOT is applied before other operations. So NOT X AND Y is read as (NOT X) AND (Y). You must use parentheses to change the way this is interpreted.\n\nx <- c(TRUE, FALSE, TRUE, FALSE)\ny <- c(TRUE, TRUE, FALSE, FALSE)\n\nx & y # AND\n\n[1]  TRUE FALSE FALSE FALSE\n\nx | y # OR\n\n[1]  TRUE  TRUE  TRUE FALSE\n\n!x & y # NOT X AND Y\n\n[1] FALSE  TRUE FALSE FALSE\n\nx & !y # X AND NOT Y\n\n[1] FALSE FALSE  TRUE FALSE\n\n\nDe Morgan’s Laws\nDe Morgan’s Laws are a set of rules for how to combine logical statements. You can represent them in a number of ways:\n\nNOT(A or B) is equivalent to NOT(A) and NOT(B)\nNOT(A and B) is equivalent to NOT(A) or NOT(B)\n\n\n\nDefinitions\nDeMorgan’s First Law\nDeMorgan’s Second Law\n\n\n\n Suppose that we set the convention that .\n\n\n\n\nA venn diagram illustration of De Morgan’s laws showing that the region that is outside of the union of A OR B (aka NOT (A OR B)) is the same as the region that is outside of (NOT A) and (NOT B)\n\n\n\n\n\n\nA venn diagram illustration of De Morgan’s laws showing that the region that is outside of the union of A AND B (aka NOT (A AND B)) is the same as the region that is outside of (NOT A) OR (NOT B)\n\n\n\n\n\nData Structures\nIn the previous chapter, we discussed 4 different data types: strings/characters, numeric/double/floats, integers, and logical/booleans. As you might imagine, things are about to get more complicated.\nData structures are more complicated arrangements of information.\n\n\nHomogeneous\nHeterogeneous\n\n\n\n\n1D\nvector\nlist\n\n\n2D\nmatrix\ndata frame\n\n\nN-D\narray\n\n\n\n\nLists\nA list is a one-dimensional column of heterogeneous data - the things stored in a list can be of different types.\n\n\nA lego list: the bricks are all different types and colors, but they are still part of the same data structure.\n\n\n\nx <- list(\"a\", 3, FALSE)\nx\n\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] FALSE\n\n\nThe most important thing to know about lists, for the moment, is how to pull things out of the list. We call that process indexing.\nIndexing\nEvery element in a list has an index (a location, indicated by an integer position)1.\nIn R, we count from 1.\n\n\nAn R-indexed lego list, counting from 1 to 5\n\n\n\nx <- list(\"a\", 3, FALSE)\n\nx[1] # This returns a list\n\n[[1]]\n[1] \"a\"\n\nx[1:2] # This returns multiple elements in the list\n\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] 3\n\nx[[1]] # This returns the item\n\n[1] \"a\"\n\nx[[1:2]] # This doesn't work - you can only use [[]] with a single index\n\nError in x[[1:2]]: subscript out of bounds\n\n\nIn R, list indexing with [] will return a list with the specified elements.\nTo actually retrieve the item in the list, use [[]]. The only downside to [[]] is that you can only access one thing at a time.\nWe’ll talk more about indexing as it relates to vectors, but indexing is a general concept that applies to just about any multi-value object.\nVectors\nA vector is a one-dimensional column of homogeneous data. Homogeneous means that every element in a vector has the same data type.\nWe can have vectors of any data type and length we want: \n\nIndexing by Location\nEach element in a vector has an index - an integer telling you what the item’s position within the vector is. I’m going to demonstrate indices with the string vector\n\n\n\n\n\n\nR\nPython\n\n\n\n1-indexed language\n0-indexed language\n\n\nCount elements as 1, 2, 3, 4, …, N\nCount elements as 0, 1, 2, 3, , …, N-1\n\n\n\n\n\n\n\nIn R, we create vectors with the c() function, which stands for “concatenate” - basically, we stick a bunch of objects into a row.\n\ndigits_pi <- c(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5)\n\n# Access individual entries\ndigits_pi[1]\n\n[1] 3\n\ndigits_pi[2]\n\n[1] 1\n\ndigits_pi[3]\n\n[1] 4\n\n# R is 1-indexed - a list of 11 things goes from 1 to 11\ndigits_pi[0]\n\nnumeric(0)\n\ndigits_pi[11]\n\n[1] 5\n\n# Print out the vector\ndigits_pi\n\n [1] 3 1 4 1 5 9 2 6 5 3 5\n\n\nWe can pull out items in a vector by indexing, but we can also replace specific things as well:\n\nfavorite_cats <- c(\"Grumpy\", \"Garfield\", \"Jorts\", \"Jean\")\n\nfavorite_cats\n\n[1] \"Grumpy\"   \"Garfield\" \"Jorts\"    \"Jean\"    \n\nfavorite_cats[2] <- \"Nyan Cat\"\n\nfavorite_cats\n\n[1] \"Grumpy\"   \"Nyan Cat\" \"Jorts\"    \"Jean\"    \n\n\nIf you’re curious about any of these cats, see the footnotes2.\nIndexing with Logical Vectors\nAs you might imagine, we can create vectors of all sorts of different data types. One particularly useful trick is to create a logical vector that goes along with a vector of another type to use as a logical index.\n\n\nlego vectors - a pink/purple hued set of 1x3 bricks representing the data and a corresponding set of 1x1 grey and black bricks representing the logical index vector of the same length\n\n\nIf we let the black lego represent “True” and the grey lego represent “False”, we can use the logical vector to pull out all values in the main vector.\n\n\n\n\n\n\nBlack = True, Grey = False\nGrey = True, Black = False\n\n\n\n\n\n\nNote that for logical indexing to work properly, the logical index must be the same length as the vector we’re indexing. This constraint will return when we talk about data frames, but for now just keep in mind that logical indexing doesn’t make sense when this constraint isn’t true.\n\n# Define a character vector\nweekdays <- c(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\")\nweekend <- c(\"Sunday\", \"Saturday\")\n\n# Create logical vectors\nrelax_days <- c(1, 0, 0, 0, 0, 0, 1) # doing this the manual way\nrelax_days <- weekdays %in% weekend # This creates a logical vector \n                                    # with less manual construction\nrelax_days\n\n[1]  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n\nschool_days <- !relax_days # FALSE if weekend, TRUE if not\nschool_days\n\n[1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n\n# Using logical vectors to index the character vector\nweekdays[school_days] # print out all school days\n\n[1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"   \n\n\nReviewing Types\nAs vectors are a collection of things of a single type, what happens if we try to make a vector with differently-typed things?\n\nc(2L, FALSE, 3.1415, \"animal\") # all converted to strings\n\n[1] \"2\"      \"FALSE\"  \"3.1415\" \"animal\"\n\nc(2L, FALSE, 3.1415) # converted to numerics\n\n[1] 2.0000 0.0000 3.1415\n\nc(2L, FALSE) # converted to integers\n\n[1] 2 0\n\n\nAs a reminder, this is an example of implicit type conversion - R and python decide what type to use for you, going with the type that doesn’t lose data but takes up as little space as possible.\nMatrices\nA matrix is the next step after a vector - it’s a set of values arranged in a two-dimensional, rectangular format.\nMatrix (Lego)\n\n\nlego depiction of a 3-row, 4-column matrix of 2x2 red-colored blocks\n\n\n\n# Minimal matrix in R: take a vector, \n# tell R how many rows you want\nmatrix(1:12, nrow = 3)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\nmatrix(1:12, ncol = 3) # or columns\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\n# by default, R will fill in column-by-column\n# the byrow parameter tells R to go row-by-row\nmatrix(1:12, nrow = 3, byrow = T)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\n# We can also easily create square matrices \n# with a specific diagonal (this is useful for modeling)\ndiag(rep(1, times = 4))\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    0    1    0    0\n[3,]    0    0    1    0\n[4,]    0    0    0    1\n\n\nThis class comes before linear algebra in the required course sequence, so most of the problems we’re going to work on will not require much in the way of matrix or array operations. For now, you need the following:\n\nKnow that matrices exist and what they are (2-dimensional arrays of numbers)\nUnderstand how they are indexed (because it is extremely similar to data frames that we’ll work with in the next chapter)\nBe aware that there are lots of functions that depend on matrix operations at their core (including linear regression)\nIndexing in Matrices\nBoth R and python use [row, column] to index matrices. To extract the bottom-left element of a 3x4 matrix in R, we would use [3,1] to get to the third row and first column entry; in python, we would use [2,0] (remember that Python is 0-indexed).\nAs with vectors, you can replace elements in a matrix using assignment.\n\nmy_mat <- matrix(1:12, nrow = 3, byrow = T)\n\nmy_mat[3,1] <- 500\n\nmy_mat\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]  500   10   11   12\n\n\nMatrix Operations\nThere are a number of matrix operations that we need to know for basic programming purposes:\n\nscalar multiplication \\[c*\\textbf{X} = c * \\left[\\begin{array}{cc} x_{1,1} & x_{1, 2}\\\\x_{2,1} & x_{2,2}\\end{array}\\right] = \\left[\\begin{array}{cc} c*x_{1,1} & c*x_{1, 2}\\\\c*x_{2,1} & c*x_{2,2}\\end{array}\\right]\\]\n\ntranspose - flip the matrix across the left top -> right bottom diagonal. \\[t(\\textbf{X}) = \\left[\\begin{array}{cc} x_{1,1} & x_{1, 2}\\\\x_{2,1} & x_{2,2}\\end{array}\\right]^T = \\left[\\begin{array}{cc} x_{1,1} & x_{2,1}\\\\x_{1,2} & x_{2,2}\\end{array}\\right]\\]\n\nmatrix multiplication (dot product) - you will learn more about this in linear algebra, but here’s a preview. Here is a better explanation of the cross product \\[\\textbf{X}*\\textbf{Y} = \\left[\\begin{array}{cc} x_{1,1} & x_{1, 2}\\\\x_{2,1} & x_{2,2}\\end{array}\\right] * \\left[\\begin{array}{cc} y_{1,1} \\\\y_{2,1} \\end{array}\\right] = \\left[\\begin{array}{c}x_{1,1}*y_{1,1} + x_{1,2}*y_{2,1} \\\\x_{2, 1}*y_{1,1} + x_{2,2}*y_{2,1}\\end{array}\\right]\\] Note that matrix multiplication depends on having matrices of compatible dimensions. If you have two matrices of dimension \\((a \\times b)\\) and \\((c \\times d)\\), then \\(b\\) must be equal to \\(c\\) for the multiplication to work, and your result will be \\((a \\times d)\\).\n\n\nx <- matrix(c(1, 2, 3, 4), nrow = 2, byrow = T)\ny <- matrix(c(5, 6), nrow = 2)\n\n# Scalar multiplication\nx * 3\n\n     [,1] [,2]\n[1,]    3    6\n[2,]    9   12\n\n3 * x\n\n     [,1] [,2]\n[1,]    3    6\n[2,]    9   12\n\n# Transpose\nt(x)\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nt(y)\n\n     [,1] [,2]\n[1,]    5    6\n\n# matrix multiplication (dot product)\nx %*% y\n\n     [,1]\n[1,]   17\n[2,]   39\n\n\nArrays\nArrays are a generalized n-dimensional version of a vector: all elements have the same type, and they are indexed using square brackets in both R and python: [dim1, dim2, dim3, ...]\nI don’t think you will need to create 3+ dimensional arrays in this class, but if you want to try it out, here is some code.\n\narray(1:8, dim = c(2,2,2))\n\n, , 1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n, , 2\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n\n\nNote that displaying this requires 2 slices, since it’s hard to display 3D information in a 2D terminal arrangement."
  },
  {
    "objectID": "00-prereading.html#checkin1-prereading",
    "href": "00-prereading.html#checkin1-prereading",
    "title": "Pre-reading",
    "section": "Check-in 1: Pre-reading Quiz",
    "text": "Check-in 1: Pre-reading Quiz"
  },
  {
    "objectID": "01-introduction.html",
    "href": "01-introduction.html",
    "title": "\n1  Introduction\n",
    "section": "",
    "text": "Reading: 19 minute(s) at 200 WPM.\nVideos:"
  },
  {
    "objectID": "01-introduction.html#getting-started",
    "href": "01-introduction.html#getting-started",
    "title": "\n1  Introduction\n",
    "section": "\n1.1 Getting Started",
    "text": "1.1 Getting Started\n\n1.1.1 Setting up your computer\nIn this section, I will provide you with links to set up various programs on your own machine. If you have trouble with these instructions or encounter an error, post on the class message board or contact me for help.\n\n1.1.1.1 Check-in 3: Installing R, RStudio, and Quarto\n\n\nDownload and run the R installer for your operating system from CRAN:\n\nWindows: https://cran.rstudio.com/bin/windows/base/\nMac: https://cran.rstudio.com/bin/macosx/\nLinux: https://cran.rstudio.com/bin/linux/ (pick your distribution)\n\nIf you are on Windows, you should also install the Rtools4 package; this will ensure you get fewer warnings later when installing packages.\nMore detailed instructions for Windows are available here\n\nDownload and install the latest version of RStudio for your operating system. RStudio is a integrated development environment (IDE) for R - it contains a set of tools designed to make writing R code easier.\nDownload and install the latest version of Quarto for your operating system. Quarto is a command-line tool released by RStudio that allows Rstudio to work with python and other R specific tools in a unified way.\n\nMake sure you remember to create your RProject and upload a screenshot to canvas.\n\n\nIf you would like a video tutorial on downloading RStudio, here is one: \n\n\n\n\n\n\n1.1.1.2 Directories, Paths, and Projects\nIn File Systems we learned about …\n\n1.1.1.3 Check-in 3: RProject\n\nTake a screenshot of your class directory, showing the R Project and the folder organization, including a Week 1 or Practice Activity folder. Upload this screenshot to canvas.\n\n\n1.1.1.3.1 Workflow\nWorkflow and Projects\nSoftware Carpentry – Project Managment with RStudio"
  },
  {
    "objectID": "01-introduction.html#scripts-and-notebooks",
    "href": "01-introduction.html#scripts-and-notebooks",
    "title": "\n1  Introduction\n",
    "section": "\n1.2 Scripts and Notebooks",
    "text": "1.2 Scripts and Notebooks\nIn this class, we’ll be using markdown notebooks to keep our code and notes in the same place. One of the advantages of both R and Python is that they are both scripting languages, but they can be used within notebooks as well. This means that you can have an R script file or a python script file, and you can run that file, but you can also create a document (like the one you’re reading now) that has code AND text together in one place. This is called literate programming and it is a very useful workflow both when you are learning programming and when you are working as an analyst and presenting results.\n\n1.2.1 Scripts\nBefore I show you how to use literate programming, let’s look at what it replaces: scripts. Scripts are files of code that are meant to be run on their own. They may produce results, or format data and save it somewhere, or scrape data from the web – scripts can do just about anything.\nScripts can even have documentation within the file, using # characters (at least, in R and python) at the beginning of a line. # indicates a comment – that is, that the line does not contain code and should be ignored by the computer when the program is run. Comments are incredibly useful to help humans understand what the code does and why it does it.\n\nPlotting a logarithmic spiral\nThis code will use concepts we have not yet introduced - feel free to tinker with it if you want, but know that you’re not responsible for being able to write this code yet. You just need to read it and get a sense for what it does. I have heavily commented it to help with this process.\n\n# Define the angle of the spiral (polar coords)\n# go around two full times (2*pi = one revolution)\ntheta <- seq(0, 4*pi, .01) \n# Define the distance from the origin of the spiral\n# Needs to have the same length as theta\nr <- seq(0, 5, length.out = length(theta))\n\n# Now define x and y in cartesian coordinates\nx <- r * cos(theta)\ny <- r * sin(theta)\n\nplot(x, y, type = \"l\")\n\n\n\nFigure 1.1: A Cartesian Spiral in R\n\n\n\n\nI have saved this script here. You can download it and open it up in RStudio (File -> Open -> Navigate to file location).\nScripts can be run in Rstudio by clicking the Run button  at the top of the editor window when the script is open.\n\n\n\n\n\n\nMost of the time, you will run scripts interactively - that is, you’ll be sitting there watching the script run and seeing what the results are as you are modifying the script. However, one advantage to scripts over notebooks is that it is easy to write a script and schedule it to run without supervision to complete tasks which may be repetitive. I have a script that runs daily at midnight, 6am, noon, and 6pm to pull information off of the internet for a dataset I’m maintaining. I’ve set it up so that this all happens automatically and I only have to check the results when I am interested in working with that data.\n\n1.2.2 Notebooks\nNotebooks are an implementation of literate programming. R has native notebooks that allow you to code in R. This book is written using Quarto markdown, which is an extension of Rmarkdown.\nIn this class, we’re going to use Quarto/R markdown. This matters because the goal is that you learn something useful for your own coding and then you can easily apply it when you go to work as an analyst somewhere to produce impressive documents.\n\n1.2.2.0.1 Introduction to Quarto\n\nR4DS: Quarto\nIntro to Quarto\nComputations in Quarto\nAuthoring & Formatting Quarto Documents\n\n1.2.2.0.2 Learn more about Notebooks and Quarto\nThere are some excellent opinions surrounding the use of notebooks in data analysis:\n\n\nWhy I Don’t Like Notebooks” by Joel Grus at JupyterCon 2018\n\nThe First Notebook War by Yihui Xie (response to Joel’s talk).\nYihui Xie is the person responsible for knitr and Rmarkdown.\n\nYou can find the entire list of options you can use to format your HTML file with Quarto here. Poke around the gallery of cool HTML documents rendered with Quarto:\n\nInteractive document published to the web\nAdvanced Layout with HTML"
  },
  {
    "objectID": "01-introduction.html#finding-your-way-in-r",
    "href": "01-introduction.html#finding-your-way-in-r",
    "title": "\n1  Introduction\n",
    "section": "\n1.3 Finding your way in R\n",
    "text": "1.3 Finding your way in R\n\n\n1.3.1 Programming\n\nProgramming today is a race between software engineers striving to build bigger and better idiot-proof programs, and the universe trying to produce bigger and better idiots. So far, the universe is winning. - Rick Cook\n\nProgramming is the art of solving a problem by developing a sequence of steps that make up a solution, and then very carefully communicating those steps to the computer. To program, you need to know how to\n\nbreak a problem down into smaller, easily solvable problems\nsolve small problems\ncommunicate the solution to a computer using a programming language\n\nIn this class, we’ll be using both R and Python, and we’ll be using these languages to solve problems that are related to working with data. At first, we’ll start with smaller, simpler problems that don’t involve data, but by the end of the semester, you will hopefully be able to solve some statistical problems using one or both languages.\nIt will be hard at first - you have to learn the vocabulary in both languages in order to be able to put commands into logical “sentences”. The problem solving skills are the same for all programming languages, though, and while those are harder to learn, they’ll last you a lifetime.\n\n1.3.2 Hello world\nI particularly like the way that Python for Everybody (Severance 2016) explains coding vocabulary:\n\nUnlike human languages, the [R] vocabulary is actually pretty small. We call this “vocabulary” the “reserved words”. These are words that have very special meaning to [R]. When [R] sees these words in a [R] program, they have one and only one meaning to [R]. Later as you write programs you will make up your own words that have meaning to you called variables. You will have great latitude in choosing your names for your variables, but you cannot use any of [R]’s reserved words as a name for a variable.\n\n\nWhen we train a dog, we use special words like “sit”, “stay”, and “fetch”. When you talk to a dog and don’t use any of the reserved words, they just look at you with a quizzical look on their face until you say a reserved word. For example, if you say, “I wish more people would walk to improve their overall health”, what most dogs likely hear is, “blah blah blah walk blah blah blah blah.” That is because “walk” is a reserved word in dog language. Many might suggest that the language between humans and cats has no reserved words.\n\n\nThe reserved words in the language where humans talk to [R] include the following:\n\nif          else     repeat      while        \nfor         in       next        break  \nTRUE        FALSE    NULL        Inf         \nNA_integer_ NA_real_ NA_complex_ NA_character_  \nNaN         NA       function    ...\n\nThat is it, and unlike a dog, [R] is already completely trained. When you say ‘try’, [R] will try every time you say it without fail.\n\n\nWe will learn these reserved words and how they are used in good time, but for now we will focus on the [R] equivalent of “speak” (in human-to-dog language). The nice thing about telling [R] to speak is that we can even tell it what to say by giving it a message in quotes:\n\n\nprint('Hello world!')\n\n[1] \"Hello world!\"\n\n\n\nAnd we have even written our first syntactically correct [R] sentence. Our sentence starts with the function print followed by a string of text of our choosing enclosed in single quotes. The strings in the print statements are enclosed in quotes. Single quotes and double quotes do the same thing; most people use single quotes except in cases like this where a single quote (which is also an apostrophe) appears in the string.\n\n\n1.3.3 Talking to R - Interactive mode\nR has an “interactive mode” that you will use most often. In the previous section, we talked about scripts and quarto/markdown documents, both of which are non-interactive methods for writing R code. But for the moment, let’s work with the interactive console in order to get familiar with how we talk to R.\nLet’s start by creating a Qmd file (File -> New File -> Quarto Document)..\nAdd an R chunk to your file by typing ```{r} into the first line of the file, and then hit return. RStudio should add a blank line followed by ```.\nYour file should look like this:\n\n\nScreenshot of qmd file after adding an empty r and python chunk\n\n\nIf instead your file looks like this:\n\n\nScreenshot of qmd file with visual markdown editing on\n\n\nyou have visual markdown mode on. To turn it off, click on the A icon at the top right of your editor window:\n\n\nScreenshot of editor window toolbar, with A icon highlighted in green\n\n\nIf we are working in interactive mode, why did I have you start out by creating a markdown document? Good Question! RStudio allows you to switch back and forth between R and python seamlessly, which is good and bad - it’s hard to get a python terminal without telling R which language you’re working in! You can create a python script if you’d prefer to work in a script instead of a markdown document, but that would involve working in 2 separate files, which I personally find rather tedious.\n\nThe R Console\n\n\nIn your R chunk or script, type in 2+2 and hit Ctrl+Enter (or Cmd+Enter on a mac). Look down to the Console (which is usually below the editor window) and see if 4 appears. If you’re like me, output shows up in two places at once:\n\n\n\n\n\n\nLocation\nPicture\n\n\n\nChunk\n\n\n\nScript\n\n\n\nConsole\n\n\n\n\nR will indicate that it is waiting for your command with a > character in the console. If you don’t see that > character, chances are you’ve forgotten to finish a statement - check for parentheses and brackets.\nWhen you are working in an R script, any output is shown only in the console. When you are working in an R code chunk, output is shown both below the chunk and in the console.\nIf you want, you can also just work within the R console. This can be useful for quick, interactive work, or if, like me, you’re too lazy to pull up a calculator on your machine and you just want to use R to calculate something quickly. You just type your R command into the console:\n\n\nR console with commands “Hello”, print(“Hello”), and (unquoted) “I love R”, which causes an error\n\n\nThe first two statements in the above example work - “Hello” is a string, and is thus a valid statement equivalent to typing “2” into the console and getting “2” back out. The second command, print(\"Hello\"), does the same thing - “Hello” is returned as the result. The third command, I love R, however, results in an error - there is an unexpected symbol (the space) in the statement. R thinks we are telling it to do something with variables I and love (which are not defined), and it doesn’t know what we want it to do to the two objects.\nSuppose we define I and love as variables by putting a value into each object using <-, which is the assignment operator. Then, typing “I love” into the console generates the same error, and R tells us “hey, there’s an unexpected symbol here” - in this case, maybe we meant to add the two variables together.\n\n\nR console with commands “Hello”, print(“Hello”), and (unquoted) “I love R”, which causes an error. Defining variables I and love provides us a context in which R’s error message about unexpected symbols makes sense - R is reminding us that we need a numerical operator in between the two variable names.\n\n\n\n\n\n\n1.3.4 Talking to R - Script Mode\nIn the previous section, we played around with scripts and Quarto / markdown documents for R. In the last section, we played with interactive mode by typing R commands into a console or running code chunks interactively using the Run button or Ctrl/Cmd + Enter (which is the keyboard shortcut).\nYou may be learning to program in R because it’s a required part of the curriculum, but hopefully, you also have some broader ideas of what you might do with either language - process data, make pretty pictures, write a program to trigger the computer uprising…\nScripts are best used when you have a thing you want to do, and you will need to do that thing many times, perhaps with different input data. Suppose that I have a text file and I want to pull out the most common word in that file. In the next few examples, I will show you how to do this in R, and at the same time, demonstrate the difference between interactive mode and script mode. In each example, try to compare to the previous example to identify whether something is running as a full script or in interactive mode, and how it is launched (in R? at the command line?).\n\nExample: Counting Words\n\n\nR within RStudio\nR in Interactive Mode\nR on the Command Line\n\n\n\nJust for fun, let’s work with Oliver Twist, by Charles Dickens, which I have saved here.\n\n# Read in the file\ntext <- readLines(\"dickens-oliver-627.txt\")\n\n# Split the lines of text into separate words\ntext <- strsplit(text, \" \")\n\n# Simplify the list\ntext <- unlist(text)\n\n# Count up the number of occurrences of each word\nword_freq <- table(text)\n\n# Sort the table by decreasing frequency\nword_freq <- sort(word_freq, decreasing = T)\n\n# Show the counts for the most common 10 words\nword_freq[1:10]\n\nMake a new R script (File -> New File -> R script) and copy the above code into R, or download the file to your computer directly and open the downloaded file in RStudio.\nIn the R console, run the command getwd() to see where R is running from. This is your “working directory”.\n\n\nR editor window with relevant script, with R console shown below. My working directory is /home/susan/Projects/Class/unl-stat151/stat151book/demo; yours will be different.\n\n\nSave the copy of Oliver Twist to the file dickens-oliver-627.txt in the folder that getwd() spit out. You can test that you have done this correctly by typing list.files() into the R console window and hitting enter. It is very important that you know where on your computer R is looking for files - otherwise, you will constantly get “file not found” errors, and that will be very annoying.\n\n\nR editor window with relevant script, with R console shown below. dickens-oliver-627.txt is in the working directory, so we can proceed.\n\n\nUse the “Run” button to run the script and see what the output is. How many times does ‘the’ appear in the file?\n\n\nUsing the file you created above, let’s examine what each line does in interactive mode.\n\n# Read in the file\ntext <- readLines(\"dickens-oliver-627.txt\")\n\nSelect the above line and click the “Run” button in RStudio. Once you’ve done that, type in text[1:5] in the R console to see the first 5 lines of the file.\n\n\nRStudio editor window with the first 2 lines of the words-noinput.R file selected. The screenshot also shows the console window after running the first 2 lines of the R file, with the text[1:5] command run interactively afterwards showing the first 5 lines of the text file we read in.\n\n\nRun the next line of code using the run button (or click on the line of code and hit Ctrl/Cmd + Enter).\n\n# Split the lines of text into separate words\ntext <- strsplit(text, \" \")\n\nType in text[[1]] to see what the text object looks like now.\n\ntext[[1]]\n\n [1] \"The\"       \"Project\"   \"Gutenberg\" \"Etext\"     \"of\"        \"Oliver\"   \n [7] \"Twist\"     \"by\"        \"Charles\"   \"Dickens\"  \n\n\n\n\nScreenshot of RStudio editor window with lines of code highlighted, plus RStudio console with the code as run and text[[1]] showing the first entry in the text object - a list of the separate words in the first line of the text file.\n\n\n\n# Simplify the list\ntext <- unlist(text)\ntext[[1]]\n\n[1] \"The\"\n\ntext[1:20]\n\n [1] \"The\"       \"Project\"   \"Gutenberg\" \"Etext\"     \"of\"        \"Oliver\"   \n [7] \"Twist\"     \"by\"        \"Charles\"   \"Dickens\"   \"#13\"       \"in\"       \n[13] \"our\"       \"series\"    \"by\"        \"Charles\"   \"Dickens\"   \"Copyright\"\n[19] \"laws\"      \"are\"      \n\n\nRunning unlist on text simplifies the object so that it is now a single vector of every word in the file, without regard for which line it appears on.\n\n# Count up the number of occurrences of each word\nword_freq <- table(text)\nword_freq[1:5]\n\ntext\n          ''cause  ''Cause   ''Cod, '--Heerd \n    4558        1        1        1        1 \n\n\nThe next line assembles a table of frequency counts in text. There are 4558 spaces, 4 occurrences of the string _I_, and so on.\n\n# Sort the table by decreasing frequency\nword_freq <- sort(word_freq, decreasing = T)\nword_freq[1:5]\n\ntext\n the  and        to   of \n8854 4902 4558 3767 3763 \n\n\nWe can then sort word_freq so that the most frequent words are listed first. The final line just prints out the first 10 words instead of the first 5.\n\n\nDownload the following file to your working directory: words.R, or paste the following code into a new R script and save it as words.R\n\n# Take arguments from the command line\nargs <- commandArgs(TRUE)\n\n# Read in the file\ntext <- readLines(args[1])\n\n# Split the lines of text into separate words\ntext <- strsplit(text, \" \")\n\n# Simplify the list\ntext <- unlist(text)\n\n# Count up the number of occurrences of each word\nword_freq <- table(text)\n\n# Sort the table by decreasing frequency\nword_freq <- sort(word_freq, decreasing = T)\n\n# Show the counts for the most common 10 words\nword_freq[1:10]\n\nIn a terminal window opened at the location you saved the file (and the corresponding text file), enter the following: Rscript words.R dickens-oliver-627.txt.\nHere, Rscript is the command that tells R to evaluate the file, words.R is the R code to run, and dickens-oliver-627.txt is an argument to your R script that tells R where to find the text file. This is similar to the python code, but instead, the user passes the file name in at the same time as the script instead of having to wait around a little bit.\n\n\n\n\n\n1.3.4.1 Additional Resources: Basics of R and RStudio\nBasics of R Programming\nBasics of R\nRStudio Primer, Basics of Programming in R\nIntroduction to RStudio\nA tour of RStudio, BasicsBasics1\nQuick tour of RStudio\n\nCheck-in 4: Introduction to R & RStudio\nAnswer the following questions on the Canvas Quiz.\nQuestion 1: What does it mean for R to be “open-source”?\n\nUsers are required to share all the code they write.\nPrivate companies must pay the R Core Group to use R.\nDevelopers cannot charge for the use of their R software.\nAnyone can change the base functionality of R.\n\nQuestion 2: How often do you need to install a package on your computer?\nQuestion 3: What is the tidyverse?\n\n1.3.5 Getting help\nIn R, you can access help with a ?. Suppose we want to get help on a for loop. In the R console, we can run this line of code to get help on for loops.\n\n?`for`\n\nstarting httpd help server ... done\n\n\nBecause for is a reserved word in R, we have to use backticks (the key above the TAB key) to surround the word for so that R knows we’re talking about the function itself. Most other function help can be accessed using ?function_name.\n(You will have to run this in interactive mode for it to work)\nw3schools has an excellent R help on basic functions that may be useful as well - usually, these pages will have examples.\n\n1.3.5.1 Google is your friend.\nThe R community has an enormous aresenal of online learning resources. I will linked a few throughout the “read more” sections in this text, but you can always find more!\n\nLearn to:\n\nGoogle for tutorials and examples\nUse Stack Overflow\n\nAsk questions on Twitter\nMake good use of the vast and welcoming R network on the internet\n\n1.3.6 PA 1: Find the Mistakes\nYou can access PA1: Find the Mistakes one of two ways:\n\nClick here to access an RStudio Cloud project which we work on in groups on Day 1 of the course (Note: if you do not have an RStudio Cloud account, you will be asked to create one).\nIf you have already installed R, RStudio, and Quarto, you can create a new Quarto document, and copy the practice activity template into the file (Note: make sure your quarto file is on Source mode and not Visual mode when you copy the template).\n\nThe components of the Practice Activity are described below:\nPart One:\nThis file has many mistakes in the code. Some are errors that will prevent the file from knitting; some are mistakes that do NOT result in an error.\nFix all the problems in the code chunks.\nPart Two:\nFollow the instructions in the file to uncover a secret message.\nSubmit the name of the poem as the answer to the Canvas Quiz question.\n\n\n\n\n\nMonday classtime will be dedicated to working through practice activities in groups and will be due the following classday. In order to make classtime most effective, you may want to spend some time prior to class reviewing and preparing for the activity.\n\n\nA useful video by Dr. Theobold on “Troubleshooting in R”.\n\n\n\n\n\n\n\nSeverance, Dr Charles Russell. 2016. Python for Everybody: Exploring Data in Python 3. Edited by Sue Blumenberg and Elliott Hauser. Ann Arbor, MI: CreateSpace Independent Publishing Platform. https://www.py4e.com/html3/."
  },
  {
    "objectID": "02-tidy-data-and-basics-of-graphics.html",
    "href": "02-tidy-data-and-basics-of-graphics.html",
    "title": "\n2  Tidy Data & Basics of Graphics\n",
    "section": "",
    "text": "Reading: 1 minute(s) at 200 WPM.\nVideos:"
  },
  {
    "objectID": "02-tidy-data-and-basics-of-graphics.html#ch2-objectives",
    "href": "02-tidy-data-and-basics-of-graphics.html#ch2-objectives",
    "title": "\n2  Tidy Data & Basics of Graphics\n",
    "section": "Objectives",
    "text": "Objectives\nCheck-ins"
  }
]